### 1. Java: Matrix multiplication

- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

## Реализация

### Стандартный алгоритм умножения матриц

Стандартный алгоритм умножения матриц заключается в скалярном умножении элементов i-ой строки матрицы A и j-го столбца матрицы B и их сложении.

$$\mathbf{C}_{i, j} = \sum_{k=1}^{K} \mathbf{A}_{i, k} \cdot \mathbf{B}_{k, j}$$

Такой алгоритм имеет сложность $O(n^3)$, из-за чего он неэффективен для больших матриц.

### Оптимизированный способ умножения матриц (разбиение на блоки)

Оптимизированный способ заключается в разбиении матриц A, B и C на блоки, размером BLOCK_SIZE * BLOCK_SIZE, который основывается на размере кэша процессора или выбирается оптимальное значение методом подбора. В данной реализации выбран BLOCK_SIZE = 64. Сам алгоритм также имеет сложность $O(n^3)$, но скорость выполнения увеличивается благодаря разбиению матриц на блоки и уменьшению количество кэш-промахов.

$$\mathbf{C} = \begin{pmatrix} C_{11} & C_{12} \\ C_{21} & C_{22} \end{pmatrix}, \quad \mathbf{A} = \begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix}, \quad \mathbf{B} = \begin{pmatrix} B_{11} & B_{12} \\ B_{21} & B_{22} \end{pmatrix}$$

$$\mathbf{C}_{I, J} = \sum_{K} \mathbf{A}_{I, K} \cdot \mathbf{B}_{K, J}$$

При умножении матриц процессор обращается к строкам матрицы A и столбцам матрицы B, но стобцы матрицы B не помещаются в кэш-память, из-за чего приходится обращаться к более медленной оперативной памяти. В блочном способе оптимизации эта проблема решается уменьшением размеров матриц для умножения таким образом, что элементы столбцов матрицы B помещаются в кэш память, из-за чего происходит меньше обращений к RAM, что повышает скорость выполнения умножения.

## Сравнение 

Для небольших матриц (< 100 * 100) время выполнения обоих алгоритмов примерно одинаково, так как матрицы в любом случае полностью или почти полностью помещаются в кэш. Для больших матриц разница во времени выполнения увеличивается вместе с ростом размера матриц.

Проведя по 10 тестов умножения матриц с разными размерами получены следующие результаты:

$$
\begin{array}{|c|c|c|}
\hline
\text{Размер матриц} & \text{Стандартный алгоритм (мс)} & \text{Блочный способ (мс)} \\
\hline
500 \times 500 & 112 & 55 \\
\hline
1000 \times 1000 & 978 & 506 \\
\hline
1500 \times 1500 & 18287 & 1955 \\
\hline
\end{array}
$$
