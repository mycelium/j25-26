# HSAI 25-26 Java course - 1
## Лаб1. Java: Matrix multiplication
- Реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

## Реализация алгоритма умножения
Для простоты взаимодействия и провеки матриц был создан дополнительный класс `Matrix`, который хранит в себе `double[][]` с данными о матрице, числе ее строк и столбцов.

В этом классе реализованы два алгоритма умножения, выбор которых происходит с помощью простой эвристики: считается примерное число операций умножения и если они превосходят заданное пороговое число, вызывается оптимизированный вариант функции.

Как было упомянуто выше, всего было создано две функции умножения:
1. `private double[][] straightforwardMultiply(Matrix other)` - функция получает объект матрицы (для упрощенной проверки ее валидности), а возвращает сырые данные `double[][]`. Функция реализует простой алгоритм умножения матриц "в лоб": транспонирует вторую матрицу для более простой и прямолинейной итерации по ее элементам. В математической форме формула выглядит $C_{ij}=\sum_{k=0}^{n-1} A_{ik}\cdot B^T_{jk}$. ($C=A\times B$)
2. `private double[][] multiplyMatricesByBlocks(Matrix other)` - функция работает с данными, как и первая. Она реализует более сложный алгоритм умножения матриц, основанный на разбиении матриц на блоки для лучшей работы с кэш-памятью. Математическим языком, она вычисляет элемент матрицы результата по следующей формуле: $$C_{ij}=\sum_{\text{блоки по }k_0} \left(\sum_{k=k_0}^{\min(k_0+\text{BLOCK_SIZE}, n) - 1} A_{ik} \cdot B_{kj}\right).$$ Кроме блочного умножения, порядок во внутренних циклах умножения обеспечивает вычисление результата более оптимальным способом (формула на псевдокоде): `C[i][j0 : j1] += A[i][k] * B[k][j0 : j1]` для каждого $k$ в блоке. 