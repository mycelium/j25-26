# Оптимизация умножения  

Суть оптимизации заключается в смене порядка обхода циклов для более эффективного обращения к элементам матрицы. Обычно используется порядок i->j->k. В этом случае приходится  обращаться к разным строкам второй матрицы, которые могут находиться в разных частях кэша. Чтобы избежать этого, можно поменять порядок обхода на k->i->j. Теперь внутренний цикл проходит по последовательным элементам массивов матриц.
Кроме того, создание переменной позволяет использовать значения из первой матрицы, не прибегая к постоянному обращению. 

for (int k = 0; k < colsA; k++) {
    for (int i = 0; i < rowsA; i++) {
        double val = firstMatrix[i][k];
        for (int j = 0; j < colsB; j++) {
            result[i][j] += val * secondMatrix[k][j];
        }
    }
}  

Ниже приведено сравнение времени оптимизированного умножения и нет для матриц размерностями 500x500 и 1000x1000 соответственно. 
   
Average time for standart mult: 130 ms
Average time for optimized mult: 18 ms
---------------------------------------
Average time for standart mult: 1311 ms
Average time for optimized mult: 129 ms
