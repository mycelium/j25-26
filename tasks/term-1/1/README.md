# Java: Matrix multiplication

## Цель работы
- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix)`;
- вывести время выполнения для матриц большой размерности;
- оптимизировать время выполнения.

## Описание реализации

### Основные функции
- `multiply(double[][] firstMatrix, double[][] secondMatrix)` - стандартная реализация;
- `multiplyOptimized(double[][] firstMatrix, double[][] secondMatrix)` - оптимизированная реализация с транспонированием.

### Стандартный подход
Стандартный подход реализован по формуле умножения матриц, код выглядит следующим образом:

```
for(int i = 0; i < rowsInA; i++) {
    for (int j = 0; j < colsInB; j++) {
        double sum = 0.0;
        for (int k = 0; k < rowsInB; k++) {
            sum += firstMatrix[i][k] * secondMatrix[k][j];
        }
        result[i][j] = sum;
    }
}
```

В базовой реализации доступ к элементам второй матрицы происходит по столбцам, что в крайних случаях может приводить к промахам кэша.

#### Оптимизация через транспонирование
```
for(int i = 0; i < rowsInA; i++) {
    for (int j = 0; j < colsInB; j++) {
        double sum = 0.0;
        for (int k = 0; k < rowsInB; k++) {
            sum += firstMatrix[i][k] * secondMatrixTransposed[j][k];
        }
        result[i][j] = sum;
    }
}
```
Путем транспонирования, доступ к элементам матрицы при умножении осуществляется по строкам, что делает обращение к памяти последовательным.

#### Сравнение результатов
| Размер матрицы     | Стандартный подход | С транспонированием |
|--------------------|--------------------|---------------------|
| $200 \times 200$   | 8 ms               | 5 ms                |
| $500 \times 500$   | 188 ms             | 73 ms               |
| $1000 \times 1000$ | 1800 ms            | 787 ms              |
| $2000 \times 2000$ | 85764 ms           | 10099 ms             |
