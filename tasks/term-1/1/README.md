### 1. Java: Matrix multiplication

- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

###  Оптимизация времени выполнения 
#### Изначальный подход

Традиционный способ выполнения матричного умножения проходит по всем элементам строк первой матрицы и всем элементам столбцов второй матрицы, используя при этом три вложенных цикла и имея временную сложность \(O(n^3)\).
Ниже представлен пример реализации данного алгоритма:

`
for (int i = 0; i < numRowsFirst; i++) {
    for (int j = 0; j < numColsSecond; j++) {
        for (int k = 0; k < numRowSecond; k++) {
            result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
        }
    }
}
`
Недостаток данного алгоритма заключается в том, что он многократно обращается к одним и тем же элементам первой матрицы при выполнении скалярного произведения. Это может приводить к частым кэш-промахам при работе с большими матрицами, а значит , что каждый раз будет затрачиваться время на доступ к основной памяти при поиске одного и того же элемента первой матрицы.

#### Оптимизированный подход
 Недостаток традиционного метода можно исправить, поменяв последовательность циклов в алгоритме и сохраняя текущий элемент строки первой матрицы, чтобы не искать его каждый раз в матрице.
 Код оптимизированного алгоритма представлен ниже:
 ` for(int i=0;i<numRowsFirst;i++){
		    for(int k=0; k<numRowSecond;k++){
				double temp = firstMatrix[i][k];
			    for(int j=0;j<numColsSecond;j++){
					result[i][j]+=temp*secondMatrix[k][j];
				}
			}
		} `

В данном алгоритме создается новая переменна temp, а значит ее значение сохраняется в кэш-памяти и при дальнейшем многократном использовании данного элемента нет необходимости обращаться к основной памяти.

#### Сравнение временивыполнения алгоритмов
Для сравнения времени выполнения данных алгоритмов использовались квадратные матрицы. Результат сравнения представлен в следующей таблице:
|  Размер матриц | Традиционный |  Оптимизированный |
|----------------|--------------|-------------------|
| 500 x 500      | Данные 2     | Данные 3          |
| 1000 x 1000    | Данные 5     | Данные 6          |
| 1500 x 1500    | Данные 5     | Данные 6          |
| 2000 x 2000    | Данные 5     | Данные 6          |
