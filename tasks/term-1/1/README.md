## HSAI 25-26 Java course - 1
____
### 1. Java: Matrix multiplication
- Реализовать функцию ```public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix)```;
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)
### Реализация перемножения матриц
Классический метод умножения матриц реализует математическую формулу, по которой элемент результата `C[i][j]` вычисляется как скалярное произведение `i`-й строки матрицы A и `j`-го столбца матрицы B:

$$
C[i][j] = \sum_{k=0}^{\text{colsA}-1} A[i][k] \cdot B[k][j]
$$

где:
- A — матрица размером *(rowsA × colsA)*,
- B — матрица размером *(colsA × colsB)*,
- C — результирующая матрица *(rowsA × colsB)*.

Классический метод неэффективен при работе с большими матрицами из-за особенностей организации памяти. Участки многомерных массивов могут находиться далеко друг от друга, соответственно при изменениях k процессор не может обращаться к кэшу и считывает информацию из памяти.
```Java
double[][] result = new double[rowsA][colsB];
        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                for (int k = 0; k < colsA; k++) {
                    result[i][j] += A[i][k] * B[k][j];
                }
            }
        }
```
Основная оптимизация усовершенствованного метода заключается в транспонировании второй матрицы перед выполнением умножения. Таким образом, внутренний цикл идёт по непрерывным блокам памяти как в `A[i]`, так и в `B_T[j]`, что позволяет использовать кэш для увеличения скорости.
```Java
double[][] result = new double[rowsA][colsB];
double[][] B_T = new double[rowsA][colsB];
for (int i = 0; i < colsA; i++) {
    for (int j = 0; j < colsB; j++) {
        B_T[j][i] = B[i][j];
    }
}
for (int i = 0; i < rowsA; i++) {
	for (int j = 0; j < colsB; j++) {
		double sum = 0;
		for (int k = 0; k < colsA; k++) {
			sum += A[i][k] * B_T[j][k];
		}
	result[i][j] = sum;
    }
}
```
### Сравнение наивного и усовершенствованного методов умножения
Для получения среднего времени выполнения для каждого размера матриц умножение выполняется 10 раз, а затем находится среднее арифметическое.

Из статистики видно, что на малых матрицах (< 100 x 100) оба алгоритма почти одинаковы по скорости, однако при больших размерах усовершенствованный алгоритм работает за значительно меньшее время из-за кэш-эффективности.
| Размер | Наивный | Усовершенствованный |
|:----------------:|:---------:|:----------------:|
| 100 x 100 | 1.94 ms | 1.36 ms |
| 500 x 500 | 174.57 ms | 92.15 ms |
| 1000 x 1000 | 3685.69 ms | 820.39 ms |
| 2000 x 2000 | 49921.02 ms | 6713.46 ms |
