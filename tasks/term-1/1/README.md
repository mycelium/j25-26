# Оптимизация умножения матриц на Java


Умножение двух матриц A (размер n×m) и B (размер m×p) дает матрицу C (размер n×p), где каждый элемент C[i][j] вычисляется как скалярное произведение i-й строки матрицы A и j-го столбца матрицы B:

```
C[i][j] = Σ(A[i][k] * B[k][j]) для k от 0 до m-1
```

Простое умножение матриц имеет временную сложность O(n³) для умножения матриц размера n×n. Это означает, что при увеличении размера матрицы в два раза время выполнения увеличивается в восемь раз.


Простое умножение матриц использует три вложенных цикла:

```java
for (int i = 0; i < n1; i++) {           // проход по строкам матрицы A
    for (int j = 0; j < m2; j++) {       // проход по столбцам матрицы B
        double sum = 0;
        for (int k = 0; k < m1; k++) {   // вычисление скалярного произведения
            sum += firstMatrix[i][k] * secondMatrix[k][j];
        }
        result[i][j] = sum;
    }
}
```

Но этот метод может работать медленно, особенно на больших матрицах, потому что данные в памяти не используются эффективно, и процессору приходится много ждать из-за частых обращений к медленной памяти.

Чтобы ускорить процесс, используем оптимизацию, называемую блочным умножением. 
Блочное умножение разбивает матрицы на подматрицы (блоки) размера blockSize×blockSize и умножает их последовательно. Это значительно улучшает локальность данных:

```java
for (int i = 0; i < n1; i += blockSize) {           // блоки по строкам A
    for (int j = 0; j < m2; j += blockSize) {       // блоки по столбцам B
        for (int k = 0; k < m1; k += blockSize) {   // блоки по столбцам A / строкам B
            // умножение блоков
            for (int i1 = i; i1 < i + blockSize && i1 < n1; i1++) {
                for (int j1 = j; j1 < j + blockSize && j1 < m2; j1++) {
                    double sum = result[i1][j1];
                    for (int k1 = k; k1 < k + blockSize && k1 < m1; k1++) {
                        sum += firstMatrix[i1][k1] * secondMatrix[k1][j1];
                    }
                    result[i1][j1] = sum;
                }
            }
        }
    }
}
```

Такой способ помогает лучше использовать память компьютера — все нужные данные блоков помещаются в кэш, что значительно ускоряет доступ к ним. Благодаря этому уменьшается количество ожиданий процессора из-за медленного доступа к основной памяти. Кроме того, данные из блоков многократно используются при вычислениях, и поскольку они находятся в кэше, повторное использование происходит быстро.

Очень важно подобрать размер блока. Если он маленький, то много переключений между блоками снизят эффективность. Если слишком большой — блок не поместится в кэш, и скорость упадёт из-за частых промахов. Оптимальный размер блока обычно выбирают между 32 и 128, в зависимости от объёма кэша компьютера. В работе взят размер блока 50, что хорошо подходит для современных компьютеров.

Такой подход позволяет ускорить умножение больших матриц, например размером 1000×1000(используемым в программе), по сравнению с простым умножением, улучшая производительность за счёт эффективной работы с памятью.



## Результаты тестирования

После запуска программа выведет следующий результат:

Время каждого запуска простого умножения:  
Запуск 1: 3073 мс  
Запуск 2: 3791 мс  
Запуск 3: 3479 мс  
Запуск 4: 3645 мс  
Запуск 5: 3542 мс  
Среднее время простого умножения: 3506.0 мс  

Время каждого запуска блочного умножения:  
Запуск 1: 1173 мс  
Запуск 2: 1133 мс  
Запуск 3: 1048 мс  
Запуск 4: 1200 мс  
Запуск 5: 1117 мс  
Среднее время блочного умножения: 1134.2 мс  

Таким образом, блочное умножение работает примерно в 3 раза быстрее, чем простой метод умножения матриц на примере матриц размером 1000×1000. Это показывает явное преимущество оптимизации блочным подходом за счёт лучшего использования кэш-памяти и уменьшения количества промахов при обращении к памяти.
