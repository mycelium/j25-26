
Реализована функция `multiply(double[][] firstMatrix, double[][] secondMatrix)` для стандартного умножения матриц и улучшенная версия `multiplyOptimized(...)`, работающая быстрее при больших размерах.

В базовой реализации использовались три вложенных цикла:

result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];

Такой подход прост, но неэффективен: при каждой итерации происходит множество обращений к памяти и повторных вычислений индексов, что замедляет работу при больших матрицах.

В оптимизированной версии структура циклов сохранена, но произведены следующие изменения:

* Для каждой строки результирующей матрицы сохраняется ссылка:

 
  double[] resultRow = result[i];
  double[] firstRow = firstMatrix[i];


  Это уменьшает количество обращений к массивам через двойную индексацию (`matrix[i][j]`), что снижает нагрузку на кэш процессора.

* На каждом шаге внутреннего цикла сохраняется элемент `firstRow[k]` в локальную переменную:


  double firstValue = firstRow[k];


  Это исключает повторные обращения к памяти и ускоряет выполнение за счёт хранения значения в регистрах CPU.

* Вместо многократного вызова `matrix.length` все размеры сохраняются в отдельные переменные в начале метода.

Благодаря этим изменениям уменьшается количество операций чтения из памяти и повышается эффективность работы с кэшем, что особенно заметно при матрицах размером от 300×300 и выше.




Пример результатов
Тесты проводились со случайными матрицами размером 1000×1000, по 5 итераций для каждой версии.
Указанное время соответствует среднему значению времени выполнения.
| Размер матрицы | Итерации | Стандартная версия (мс) | Оптимизированная версия (мс) |
| ---------------| -------- | ----------------------- | ---------------------------- |
| 1000×1000      |        5 |                 3474,25 |                       672,76 |

Оптимизированная реализация примерно в 5 раз быстрее базовой версии.

Это улучшение обусловлено более эффективным использованием кэша процессора и сокращением числа обращений к памяти.

