### 1. Java: Matrix multiplication

- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

###  Оптимизация времени выполнения 
#### Изначальный подход

Традиционный способ выполнения матричного умножения проходит по всем элементам строк первой матрицы и всем элементам столбцов второй матрицы, используя три вложенных цикла с временной сложностью \(O(n^3)\). 
Ниже представлен пример реализации данного алгоритма:

 ``` java

for (int i = 0; i < numRowsFirst; i++) {
    for (int j = 0; j < numColsSecond; j++) {
        for (int k = 0; k < numRowSecond; k++) {
            result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
        }
    }
}
```
Недостаток данного алгоритма заключается в том, что он многократно обращается к одним и тем же элементам первой матрицы при выполнении скалярного произведения. Это может приводить к частым кэш-промахам при работе с большими матрицами и затрачиванию времени на доступ к основной памяти при поиске одного и того же необходимого элемента первой матрицы.

#### Оптимизированный подход
Для устранения недостатков традиционного метода может быть изменена последовательность циклов в алгоритме, а также сохранение текущего элемента строки первой матрицы, что исключает необходимость многократного поиска одного и того же элемента.
Код оптимизированного алгоритма представлен ниже:
 ``` java
    for(int i=0;i<numRowsFirst;i++){
		    for(int k=0; k<numRowSecond;k++){
				double temp = firstMatrix[i][k];
			    for(int j=0;j<numColsSecond;j++){
					result[i][j]+=temp*secondMatrix[k][j];
				}
			}
		} 
```

В данном алгоритме создается новая переменная temp, что позволяет сохранять её значение в кэш-памяти. Таким образом, при многократном использовании данного элемента нет необходимости снова обращаться к основной памяти

#### Сравнение временивыполнения алгоритмов
Для сравнения времени выполнения данных алгоритмов использовались квадратные матрицы. Результат сравнения представлен в следующей таблице:
|  Размер матриц | Традиционный |  Оптимизированный |
|----------------|--------------|-------------------|
| 500 x 500      | 226 ms       | 40 ms             |
| 1000 x 1000    | 3897 ms      | 454 ms            |
| 1500 x 1500    | 39837 ms     | 3517 ms           |


Прис сравнении методов видно, что использование оптимизированного алгоритма ускоряет время выполнения 