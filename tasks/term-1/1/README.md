# Лабораторная работа №1: оптимизация умножения матриц
## Задачи
- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

## Обоснование оптимизации
Стандартный подход использует формулу умножения матриц. В нем применяется подход $i \rightarrow j \rightarrow k$.
Код выглядит следующим образом.

    for (int i = 0; i < rowsA; i++) {
        for (int j = 0; j < colsB; j++) {
            for (int k = 0; k < colsA; k++) {
                result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
            }
        }
    }

При доступе к `B[k][j]` для фиксированного `j` и изменяющегося `k`, мы читаем элементы из разных строк матрицы `B`, что приводит
к промахам кэша. В качестве оптимизации используется подход с транспонированием второй матрицы. Транспонирование 
группирует данные так, чтобы к ним можно было обращаться последовательно, а не прыгать
по разным местам памяти. Код оптимизированного подхода приведен ниже.

    double[][] secondMatrixT = transpose(secondMatrix);

    for (int i = 0; i < rowsA; i++) {
        double[] rowA = firstMatrix[i];
        for (int j = 0; j < colsB; j++) {
            double[] rowBT = secondMatrixT[j];
            double sum = 0.0;
            for (int k = 0; k < colsA; k++) {
                sum += rowA[k] * rowBT[k];
            }
            result[i][j] = sum;
        }
    }

## Результаты
Результаты выполнения умножения матриц 4 разных размеров стандартным и оптимизированным способом представлены в таблице.

| Размер            | Стандартный подход | Оптимизированный подход |
|-------------------|--------------------|-------------------------|
| 100 $\times$ 100  | 14 с               | 9 мс                    |
| 200 $\times$ 200  | 23 мс              | 17 мс                   |
| 500 $\times$ 500  | 822 мс             | 189 мс                  |
| 1000 $\times$ 1000| 6446 мс            | 1655 мс                 |

Из таблицы видно, что подход с транспонированием второй матрицы заметно сокращает время выполнения умножения матриц.
