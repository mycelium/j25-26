# 1. Java: Matrix multiplication
## Цель работы
Реализация и оптимизация алгоритма умножения матриц с использованием различных подходов.
## Реализованные методы
### Базовый алгоритм (`multiply`)
Базовый алгоритм представляет собой прямую реализацию математического определения умножения матриц. Он использует три вложенных цикла с порядком обхода i - j - k. Этот подход демонстрирует наихудшую производительность из-за неэффективного использования кэша процессора. Ниже представлен пример реализации данного алгоритма:
```java
for (int i = 0; i < aRows; i++) {
            for (int j = 0; j < bCols; j++) {
                for (int k = 0; k < aCols; k++) {
                    result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
                }
            }
        }
```
### Метод с кэшированием строк (`multiplyOptimized`)
Наиболее эффективной оказалась оптимизация, изменяющая порядок циклов на i - k - j с одновременным кэшированием строк матриц. Этот подход обеспечивает последовательный доступ к элементам второй матрицы. Кэширование строк в локальных переменных позволяет сократить количество обращений к основным массивам, а значение элемента первой матрицы сохраняется в регистре процессора и многократно переиспользуется во внутреннем цикле. Ниже представлен пример реализации данного алгоритма:
```java
for (int i = 0; i < n; i++) {
            double[] firstRow = firstMatrix[i];
            for (int k = 0; k < m; k++) {
                double value = firstRow[k];
                double[] secondRow = secondMatrix[k];
                for (int j = 0; j < p; j++) {
                    result[i][j] += value * secondRow[j];
                }
            }
        }
```
### Метод локальных переменных (`multiplyLocalVars`)
Данный подход развивает идею кэширования, дополнительно сохраняя ссылки на строки результирующей матрицы. Это позволяет уменьшить количество обращений к элементам массива и избежать повторных вычислений индексов при записи результатов. Ниже представлен пример реализации данного алгоритма:
```java
for (int i = 0; i < n; i++) {
            double[] Ai = A[i];
            double[] Ci = C[i];
            for (int k = 0; k < m; k++) {
                double Aik = Ai[k];
                double[] Bk = B[k];
                for (int j = 0; j < p; j++) {
                    Ci[j] += Aik * Bk[j];
                }
            }
        }
```
### Метод с предварительным транспонированием (`multiplyTransposed`)
Этот алгоритм основан на предварительном транспонировании второй матрицы, что обеспечивает последовательный доступ к данным обеих матриц во время умножения. Однако дополнительные затраты на операцию транспонирования и необходимость хранения дополнительной матрицы в памяти снижают общую эффективность метода. Этот подход уступает оптимизациям, основанным на кэшировании. Ниже представлен пример реализации данного алгоритма:
```java
double[][] BT = new double[p][m];
for (int i = 0; i < m; i++) {
    for (int j = 0; j < p; j++) {
        BT[j][i] = B[i][j];
    }
}
        
double[][] C = new double[n][p];
        
for (int i = 0; i < n; i++) {
    double[] Ai = A[i];
    for (int j = 0; j < p; j++) {
        double sum = 0.0;
        double[] BTj = BT[j];
        for (int k = 0; k < m; k++) {
            sum += Ai[k] * BTj[k];
        }
        C[i][j] = sum;
    }
}
```
## Анализ результатов
Проведенное тестирование на матрицах размером 500х500, 1000х1000 и 1500х1500 показало, что эффективность оптимизаций существенно возрастает с увеличением размера матриц. На матрицах 500х500 ускорение составляет примерно 2.2 раза, тогда как на матрицах 1500х1500 достигает 12-кратного улучшения производительности. Результат сравнения представлен в следующей таблице:

| Размер матриц | Базовый метод | Кэширование строк | Локальные переменные | Транспонирование |
|:-------------:|:-------------:|:-----------------:|:--------------------:|:----------------:|
| 500×500       | 240 мс        | 109 мс            | 110 мс               | 142 мс           |
| 1000×1000     | 4239 мс       | 840 мс            | 919 мс               | 1129 мс          |
| 1500×1500     | 21198 мс      | 1762 мс           | 1772 мс              | 3781 мс          |

Наиболее эффективными оказались оптимизации, связанные с улучшением доступа к памяти через кэширование строк и изменение порядка циклов. Они демонстрируют ускорение до 12 раз на больших матрицах, что подтверждает важность учета архитектуры памяти при оптимизации вычислительных алгоритмов.