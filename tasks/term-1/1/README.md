# HSAI 25-26 Java course - 1

# 1. Java: Matrix multiplication

- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

### Реализация умножения матриц
Результатом умножения матриц A и B размерностей $l\times m$ и $m\times n$ будет матрица C размерности $l\times n$, где:
$$ c_{ij} = \sum_{r=1}^{m} a_{ir}b_{rj}\ \ (i=1,2,..,l;\ j=1,2,..,n). $$
Эта формула легко реализуется тройным циклом for с порядком обхода $i \rightarrow j \rightarrow k$, то есть с выбором
строки из первой матрицы, столбца из второй и обхода всех значений в этих матрицах.
Код метода, реализующего этот способ выглядит так:


    for (int i = 0; i < firstSizeN; i++) {
        for (int j = 0; j < secondSizeM; j++) {
            for (int k = 0; k < firstSizeM; k++) {
                output[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
            }
        }
    }
Для оптимизации этого метода можно воспользоваться кешированием, сделав его более эффективным, поменяв порядок обхода
на $k \rightarrow i \rightarrow j$. Это повышает эффективность, так как при изменении $k$ происходит обращение к разным 
строкам второй матрицы, которые находятся в разных частях кеша.
После изменения порядка циклы проходят по элементам расположенным рядом в памяти. Также для уменьшения количества
обращений к элементам матрицы вводится дополнительная переменная, которая хранит значение для элемента первой матрицы.

В результате получается такой обход:

    for (int k = 0; k < firstSizeM; k++){
        for (int i = 0; i < firstSizeN; i++){
            double value = firstMatrix[i][k];
            for (int j = 0; j < secondSizeM; j++){
                output[i][j] = value * secondMatrix[k][j];
            }
        }
    }

### Результаты
Для усреднения результата каждый тест повторяется 10 раз, в таблицу записаны средние арифметические результатов.

| Размер матрицы     | Простой метод | Эффективный метод | 
|--------------------|--------------|------------------|
| $100 \times 100$   | 5 ms         | 3 ms             | 
| $500 \times 500$   | 376 ms       | 47 ms            | 
| $1000 \times 1000$ | 8931 ms      | 710 ms           | 
| $2000 \times 2000$ | 102581 ms    | 6077 ms          | 

Можно увидеть, что эффективный метод действительно значительно более эффективен, чем простой.

_Полный вывод программы для моего запуска можно увидеть в файле results.txt._