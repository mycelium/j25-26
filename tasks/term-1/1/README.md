## Стандартное умножение матриц 
В методе ``` public static double[][] multiply(double[][] oneMatrix, double[][] twoMatrix) ``` используется стандартным способ реализации умножения двух матриц, который не является оптимальным. При такой реализации происходит вытяснение данных из кэша процессора, что приводит к "промахам кэша" и замедлению работы.

```java
double[][] result = new double[rows1][cols2];
        for (int i = 0; i < rows1; i++) {
            for (int j = 0; j < cols2; j++) {
                double sum = 0.0;
                for (int k = 0; k < cols1; k++) {
                    sum += oneMatrix[i][k] * twoMatrix[k][j];
                }
                result[i][j] = sum;
            }
        }
```

## Блочное умножение матриц
Для решения этой проблемы был реализован блочный алгоритм, который разбивает матрицы на небольшие блоки, полностью помещающиеся в кэш-память процессора. Также для увеличения оптимизации был реализован дополнительный элемент, а именно изменение порядка обхода элементов в циклах. В умножении используется порядок i → k → j вместо классического i → j → k, который обеспечивает последовательный доступ к памяти.

Реализация включает адаптивный выбор алгоритма в зависимости от размера матриц. Для небольших матриц используется стандартный алгоритм с минимальными накладными расходами, тогда как для больших матриц автоматически активируется блочная версия.Более подробное описание работы алгоритма можно посмотреть в данной статье: https://blog2k.ru/archives/3323?ysclid=mhhn6kc9e22493689

```java
for (int i0 = 0; i0 < rows1; i0 += BLOCK_SIZE) {
    int i1 = Math.min(i0 + BLOCK_SIZE, rows1);
    for (int k0 = 0; k0 < cols1; k0 += BLOCK_SIZE) {
        int k1 = Math.min(k0 + BLOCK_SIZE, cols1);
        for (int j0 = 0; j0 < cols2; j0 += BLOCK_SIZE) {
            int j1 = Math.min(j0 + BLOCK_SIZE, cols2);
            for (int i = i0; i < i1; i++) {
                for (int k = k0; k < k1; k++) {
                    double a = oneMatrix[i][k];
                    for (int j = j0; j < j1; j++) {
                        result[i][j] += a * twoMatrix[k][j];
                    }
                }
            }
        }
    }
}
```

## Результаты

Были проведены тесты для матриц размером 2000x2000 и высчитано среднее время вычисления их умножения. Пример резульатов приведены ниже:

cреднее время базового умножения матриц для 10 тестов: 38292

среднее время блочного умножения матриц для 10 тестов: 2103

Как видно, алгоритм работает эффективнее примерно в 18 раз.


