### 1. Java: Matrix multiplication

- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

---

#### Наивный метод умножения матриц

Наивный метод выглядит так:

```java
for (int i = 0; i < firstRowCount; i++) {
	for (int j = 0; j < secondColCount; j++) {
		double sum = 0;
		for (int k = 0; k < firstColCount; k++) {
			sum += firstMatrix[i][k] * secondMatrix[k][j];
		}
		result[i][j] = sum;
	}
}
```

Он реализует стандартный алгоритм умножения матриц. Его проблема заключается в неэффективномм использовании кэш-памяти процессора. При каждой итерации происходит обращение к разным строкам второй матрицы, что приводит к загрузке данных из оперативной памяти.

#### Оптимизированный алгоритм:

Для оптимизации алгоритма был изменен порядок обхода матрицы со стандартного *i-j-k* на *i-k-j*:

```java
for (int i = 0; i < firstRowCount; i++) {
	for (int k = 0; k < firstColCount; k++) {
		double tmpVal = firstMatrix[i][k];
		for (int j = 0; j < secondColCount; j++) {
			result[i][j] += tmpVal * secondMatrix[k][j];
		}
	}
}
```

В ткаой версии фиксируется строка первой матрицы и столбец второй, а затем последовательно проходим по элементам. Таким образом обесепчивается последовательный доступ к памяти при чтении второй матрицы.

#### Сравнение времени умножения

Сравнение времен выполнения умножения матриц представлено в таблице (умножение происходит 10 раз на разных матрицах одинаковой размерности, итоговое время - усредняется):

|             | *i - j - k* | *i - k - j* |
|-------------|------------|-----------|
| 100 * 100   | 1.3 ms     | 0.7 ms    |
| 500 * 500   | 152.6 ms   | 20.8 ms   |
| 1000 * 1000 | 1315.8 ms  | 165.6 ms  |
| 2000 * 2000 | 47181.6 ms | 2541.2 ms |