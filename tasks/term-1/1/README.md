## Лаб1. Java: Matrix multiplication
- Реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

### Оптимизация умножения матриц

## Проблемы базовой реализации
1. Неэффективное использование кэша:  
   В оригинальном алгоритме доступ к `secondMatrix[k][j]` происходит по столбцам, что вызывает частые промахи кэша:  
   `result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];`
2. Многократный доступ к массивам  
  Постоянное обращение к элементам через `[i][j]` индексацию создает дополнительную нагрузку.  

## Примененные оптимизации  
1. Транспонирование второй матрицы  
   `double[][] secondMatrixT = transpose(secondMatrix);`  
   **Эффект**: Преобразуем доступ по столбцам в доступ по строкам, что улучшает локализацию данных.  
2. Локальные переменные для строк  
   `double[] firstRow = firstMatrix[i];`  
   `double[] resultRow = result[i];`   
   `double[] secondRowT = secondMatrixT[j];`
   **Эффект**: Улучшение производительности за счет кэширования ссылок.   
3. Последовательный доступ к памяти   
  `sum += firstRow[k] * secondRowT[k];`   
  **Эффект**: Оба массива читаются последовательно, что максимально использует кэш процессора.


## Результаты оптимизации

| Размер матрицы  | Базовый метод | Оптимизированный  | Ускорение |
| --------------- | ------------- | ----------------- | ----------|
|     500×500     |     125 мс    |      126 мс       |    0.99   |
|    1000×1000    |     1190 мс   |      939 мс       |    1.27   |
|    1500×1500    |     5837 мс   |      3188 мс      |    1.83   |


**Сложность алгоритма:** O(n³) - остается неизменной.
