# Задание
- Реализовать public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время (описать подходы)

# Реализация

## Алгоритм 1: Naive (базовый тройной цикл)
```java
for (int i = 0; i < n; i++) {
    for (int j = 0; j < b; j++) {
        double c = 0;
        for (int k = 0; k < a; k++) 
            c += A[i][k] * B[k][j];
        C[i][j] = c;
    }
}
```
**Плюсы:** простота, нулевая доп.память.

**Минусы:** доступ к B[k][j] идёт по столбцам, следовательно слабая кэш-локальность.

## Алгоритм 2: Transposed (с предварительным транспонированием B)
Так как в алгоритме 1 была плохая работа с кешом, то транспонируем матрицу считаем "строка × строка"
```java
for (int i = 0; i < a; i++)
for (int j = 0; j < b; j++)
    BT[j][i] = B[i][j];

for (int i = 0; i < n; i++) {
    double[] Ai = A[i];
    for (int j = 0; j < b; j++) {
        double[] BTj = BT[j];
        double c = 0;
        for (int k = 0; k < a; k++)
            c += Ai[k] * BTj[k];
        C[i][j] = c;
    }
}
```
**Плюсы:** линейный проход по данным (лучше кэш-локальность).

**Минусы:** нужна память под BT (a×b) и время на одноразовое транспонирование.

## Алгоритм 3: ParallelNaive (параллельный наивный)
Распараллеливание по строкам A с использованием IntStream.parallel():
```java
java.util.stream.IntStream.range(0, n).parallel().forEach(i -> {
    double[] Ai = A[i];
    double[] Ci = C[i];
    for (int j = 0; j < b; j++) {
        double c = 0;
        for (int k = 0; k < b; k++) {
            c += Ai[k] * B[k][j];
        }
        Ci[j] = c;
    }
});
```
**Плюсы:** простая параллель, каждый поток пишет свою строку C[i].

**Минусы:** Можно параллелить транспонированную.

# Методика измерений
Размеры: A(1000×2000) * B(2000×500).

Для каждого алгоритма — 10 прогонов, меряется суммарное время только на умножение (без генерации матриц/печати).

Генерация значений: rand.nextDouble() * 2 - 1 → равномерно в (−1, 1).

## Итог
[Naive] total=23.634 s for 10 runs

[Transposed] total=7.429 s for 10 runs

[ParallelNaive] total=0.642 s for 10 runs