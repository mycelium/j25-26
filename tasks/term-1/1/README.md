## HSAI 25-26 Java course - 1

### 1. Java: Matrix multiplication

- Реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

### Реализация умножения
Основная оптимизация заключается в изменении порядка обхода вложенных циклов для эффективного использования кэша при вычислениях. 

По формуле умножения матриц стандартный проход должен быть таким: $i \rightarrow j \rightarrow k$. Соответственно, код для этого выглядит следующим образом: 

    for (int i = 0; i < colsA; i++) {
        for (int j = 0; j < rowsA; j++) {
            for (int k = 0; k < colsB; k++) {
                result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
            }
        }
    }

Однако, в таком случае каждый раз при изменении k происходит обращение к разным строкам второй матрицы, которые могут находиться в разных частях кэша. В крайних случаях может произойти промах кэша.

Для оптимизации умножения можно поменять порядок прохода по элементам на: $k \rightarrow i \rightarrow j$. Это позволяет сделать такой код:

    for (int k = 0; k < colsA; k++) {
        for (int i = 0; i < rowsA; i++) {
            double val = firstMatrix[i][k];
            for (int j = 0; j < colsB; j++) {
                result[i][j] += val * secondMatrix[k][j];
            }
        }
    }

В такой ситуации внутренний цикл проходит по последовательным элементам массивов матриц. Более того, создание в среднем цикле переменной позволит использовать значения из первой матрицы, не прибегая к постоянному обращению.

### Сравнения порядков обхода
Для каждого размера матриц умножение выполняется 10 раз, а время усредняется.
|             | $i \rightarrow j \rightarrow k$ | $k \rightarrow i \rightarrow j$
|-------------|---------|---------|
| $500 \cdot 500$   | 151 ms | 33 ms|
| $1000 \cdot 1000$| 2845 ms | 447 ms|
| $2000 \cdot 2000$| 55029 ms | 4212 ms|

Как видно из данных таблицы изменение порядка обхода позволяет заметно уменьшить время, требуемое для умножения матриц.