# 1. Java: Matrix multiplication
* Реализовать функцию public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);
* Вывести время выполнения для матриц большой размерности
* Оптимизировать время выполнения (описать в README примененные подходы)

Изначальный подход имел следующую структуру циклов: 

```
for(int i = 0; i < a; i++) {
  for(int j = 0; j < b1; j++) {
    double sum = 0.0;
    for(int k = 0; k < a1; k++) {
      sum = sum + (firstMatrix[i][k] * secondMatrix[k][j]);
    }
    result[i][j] = sum;
  }
}
```

Для вычисления внутренний цикл k выполняет доступ к элементам j-го столбца (secondMatrix[k][j]). Когда мы к ним обращаемся происходят <<прыжки>> по памяти. Каждый раз загружаются новые блоки данных из оперативной памяти и это значительно замедляет выполнение. 

```
for (int i = 0; i < a; i++) {
    for (int k = 0; k < a1; k++) { 
        double r = firstMatrix[i][k]; 
        for (int j = 0; j < b1; j++) { 
            result[i][j] += r * secondMatrix[k][j]; 
        }
    }
}
```

В новом подходе цикл итерирует по строкам, поэтому большая часть операций происходит с данными, последовательно расположенными в памяти.

Применяя этот подход мы получаем значительную оптимизацию, каждый размер матриц был протестирован 10 раз.

||Подход 1|Подход 2|
|:-:|:-:|:-:|
|500x500|104ms|20ms|
|1000x1000|1027ms|158ms|
|2000x2000|12500ms|1981ms|
