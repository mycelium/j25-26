### Задание 1. Java: Matrix multiplication

- реализовать функцию `public static double[][] multiply(double[][] firstMatrix, double[][] secondMatrix);`
- Вывести время выполнения для матриц большой размерности
- Оптимизировать время выполнения (описать в README примененные подходы)

## Реализация:

### Стандартный метод умножения матриц:
Сначала был реализован классический алгоритм умножения матриц с тройным вложенным циклом. 
Особенностью данной реализации является порядок циклов **i → k → j**, 
который увеличивает скорость работы программы по сравнению с наивной реализацией, т.к. 
такой порядок циклов позволяет закэшировать элемент ```firstMatrix[i][k]``` 
и многократно использовать его для умножения на все элементы-строки второй матрицы, 
что сильно уменьшает количество обращений к памяти, тем самым оптимизируя процесс умножения.

```
for (int i = 0; i < firstMatrixRows; i++) {
    for (int k = 0; k < firstMatrixColumns; k++) {
        double cache = firstMatrix[i][k];
        for (int j = 0; j < secondMatrixColumns; j++) {
            resultMatrix[i][j] += cache * secondMatrix[k][j];
        }
    }
}
```

### Метод блоков

Метод блоков - это оптимизированный алгоритм умножения матриц, основанный на разбиении матриц на блоки для улучшения работы с кэш-памятью. 
Матрицы разбиваются на блоки, которые обрабатываются независимо. Для каждого блока первой матрицы и соответствующего блока второй матрицы выполняется умножение, 
при этом данные каждого блока помещаются в кэш процессора и многократно используются, что значительно сокращает количество обращений к оперативной памяти.
Алгоритм использует блоки размером 256×256 элементов. Такой размер блоков был выбран т.к. с ним в моей системе алгоритм выдавал самый быстрый результат.

```
for (int i0 = 0; i0 < firstMatrixRows; i0 += blockSize) {
    int iMax = Math.min(i0 + blockSize, firstMatrixRows);

    for (int k0 = 0; k0 < firstMatrixColumns; k0 += blockSize) {
        int kMax = Math.min(k0 + blockSize, firstMatrixColumns);

        for (int j0 = 0; j0 < secondMatrixColumns; j0 += blockSize) {
            int jMax = Math.min(j0 + blockSize, secondMatrixColumns);

            for (int i = i0; i < iMax; i++) {
                for (int k = k0; k < kMax; k++) {
                    double aik = firstMatrix[i][k];
                    for (int j = j0; j < jMax; j++) {
                        resultMatrix[i][j] += aik * secondMatrix[k][j];
                    }
                }
            }
        }
    }
}
```

## Результаты оптимизации

Для каждого размера матриц умножение выполнялось 10 раз и суммарное время усреднялось. Можно заметить, что
для матриц размером до 1000×1000 разница в производительности минимальна, т.к. данные полностью помещаются 
в кэш процессора. Однако с увеличением размерности растет и производительность метода блоков.

| Размер матрицы | Стандартное умножение | Метод блоков | Ускорение |
|----------------|-----------------------|--------------|-----------|
| 200x200        | 2 мс                  | 2 мс         | 1.00      |
| 400x600        | 14 мс                 | 11 мс        | 1.27      |
| 1000x1000      | 131 мс                | 118 мс       | 1.11      |
| 2500x1042      | 2460 мс               | 980 мс       | 2.51      |
| 2000x2000      | 1903 мс               | 794 мс       | 2.40      |
| 5000x5000      | 47829 мс              | 15675 мс     | 3.05      |