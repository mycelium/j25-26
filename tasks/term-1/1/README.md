## Описание

В этой лабораторной работе демонстрируется значительное улучшение производительности умножения матриц за счет изменения порядка вложенных циклов. Основная идея заключается в оптимизации доступа к памяти путем перестройки циклов из классического порядка i-j-k в более эффективный порядок k-i-j. Это изменение позволяет процессору более эффективно использовать кэш-память, что имеет решающее значение при работе с большими массивами данных. Реализация включает в себя встроенные механизмы для измерения времени выполнения, а также утилиты для генерации тестовых матриц произвольного размера.


## Техники оптимизации

### 1. Перестановка циклов (k-i-j против i-j-k)

Стандартный подход brute force использует порядок циклов i-j-k:

```java
// Brute Force: порядок i-j-k
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        for (int k = 0; k < shared; k++) {
            result[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
        }
    }
}
```

**Эта оптимизированная реализация использует порядок k-i-j:**

```java
// Оптимизированный: порядок k-i-j
for (int k = 0; k < shared; k++) {
    for (int i = 0; i < rows; i++) {
        double a_ik = firstMatrix[i][k];
        for (int j = 0; j < cols; j++) {
            result[i][j] += a_ik * secondMatrix[k][j];
        }
    }
}
```

### 2. Кэширование значений

Переменная `a_ik` кэширует значение `firstMatrix[i][k]`, устраняя избыточные обращения к памяти во внутреннем цикле.

### Почему это работает
Эффективность оптимизированного подхода объясняется принципами работы процессорного кэша. При использовании классического порядка циклов i-j-k происходят частые "прыжки" по элементам второй матрицы, что приводит к большому количеству промахов кэша. Процессору приходится постоянно обращаться к оперативной памяти, что значительно замедляет вычисления. В отличие от этого, порядок k-i-j обеспечивает последовательный доступ к элементам второй матрицы, что позволяет эффективно использовать предзагруженные в кэш данные.

Дополнительное ускорение достигается за счет кэширования значения firstMatrix[i][k] в переменной a_ik. Это исключает необходимость повторного обращения к памяти во внутреннем цикле, уменьшая нагрузку на шину памяти.
## Сравнение производительности

Для демонстрации эффективности оптимизации были проведены тесты на прямоугольных матрицах большого размера. Сравнивались два подхода: классический алгоритм с порядком циклов i-j-k (brute force) и оптимизированный вариант с порядком k-i-j с кэшированием.

### Тест : Матрицы 500×10000 и 10000×800

**Brute Force (i-j-k):**
```
ExecutionTime: 64040 ms (64 секунды)
```

**Оптимизированный (k-i-j с кэшированием):**
```
ExecutionTime: 1295 ms (1.3 секунды)
```

**Прирост производительности: в 49.5 раз быстрее**

## Запуск

Для запуска приложения:
```bash
.\gradlew.bat run
```

## Запуск тестов

Для запуска всех тестов:
```bash
.\gradlew.bat test
```

Для просмотра подробного вывода с именами тестов:
```bash
.\gradlew.bat test --rerun-tasks
```

Тесты находятся в `MatrixMultiplicationTest.java` и используют Apache Commons Math для сравнения результатов.