
Реализовать функцию:

`multiplyOptimized()` — однопоточная версия:

   * Оптимизирован доступ к элементам массива (строки и значения сохраняются в локальных переменных).
   * Используется классический алгоритм умножения матриц.

`multiplyParallel()`** — многопоточная версия:

   * Использует `ForkJoinPool` и `IntStream.parallel()` для распределения строк между потоками.
   * Количество потоков задаётся вручную через параметр `threads`:

   int threads = 8;
   multiplyParallel(firstMatrix, secondMatrix, threads);
 

 Подход к выбору количества потоков

* Количество потоков для параллельного умножения выбиралось 
* Тестировались значения: 1, 2, 4, 8, 16 потоков; измерялось время выполнения умножения больших матриц (500×500, 1000×1000).
* Минимальное время достигается при 8 потоках, что соответствует числу физических ядер процессора.
* Использование большего числа потоков (16, с учётом гипертрейдинга) не даёт значительного прироста из-за накладных расходов на управление потоками.

Вывод: оптимальное количество потоков = число физических ядер.


| Размер матрицы | Версия    | Потоки | Время (мс) |
| -------------- | --------- | ------ | ---------- |
| 500×500        | Optimized | —      |195.6548    |
| 500×500        | Parallel  | 8      | 70.826     |
| 1000×1000      | Optimized | —      | 1432.3173  |
| 1000×1000      | Parallel  | 8      | 159.7424   |

Параллельная версия работает примерно в 3–4 раза быстрее по сравнению с однопоточной реализацией для больших матриц.

