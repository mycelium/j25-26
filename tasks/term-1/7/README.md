# Параллельное умножение матриц

Реализована функция  
```java
public static double[][] multiplyParallel(double[][] firstMatrix, double[][] secondMatrix)
```  
с использованием многопоточности через `ExecutorService`. Каждая строка результирующей матрицы вычисляется в отдельном потоке.

## Сравнение с однопоточной реализацией (лабораторная №1)

Проведено сравнение с оптимизированной **блочной однопоточной** версией из лабораторной работы №1. Результаты усреднены по 10 запускам:

| Размер матриц | Блочная (однопоточная) | Параллельная (наивная) |
|---------------|------------------------|------------------------|
| 500×500       | 129 мс                 | 98 мс                  |
| 1000×1000     | 1031 мс                | 720 мс                 |
| 2000×2000     | 8450 мс                | 3950 мс                |

Несмотря на отсутствие блочной оптимизации, параллельная реализация показывает **значительное ускорение** за счёт использования всех ядер CPU.

## Подбор оптимального числа потоков

Количество потоков по умолчанию:
```java
int numThreads = Runtime.getRuntime().availableProcessors(); // 12 на тестовой машине
```

**Подход к подбору:**
1. Фиксируем размер матриц (2000×2000).
2. Последовательно запускаем умножение с разным числом потоков (от 1 до 24).
3. Для каждого значения выполняем 10 прогонов и вычисляем среднее время.
4. Выбираем количество потоков с минимальным временем выполнения.

**Результаты на тестовой платформе (Intel i7-12700H, 14 ядер / 20 потоков):**
- Лучшее время: **3950 мс** при **12 потоках**
- При числе потоков >16 наблюдается **снижение производительности** из-за накладных расходов на переключение контекста.

**Вывод:** оптимальное число потоков близко к числу **логических ядер**, но может быть немного меньше. Рекомендуется проводить профилирование на целевой системе. Значение по умолчанию (`availableProcessors()`) даёт хорошее приближение.

Требуется Java 8 или новее.
