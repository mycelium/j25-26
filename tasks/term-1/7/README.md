# 7. Java: Parallel matrix multiplication

Программа состоит из одного основного класса MatrixMult, который содержит все необходимые методы для генерации, умножения и тестирования матриц.

## Особенности реализации

Вместо прямого создания потоков через new Thread(), программа использует ExecutorService. Ниже представлен пример реализации:
```java
ExecutorService executor = Executors.newFixedThreadPool(threadCount);
// Распределение задач...
executor.shutdown();
executor.awaitTermination(1, TimeUnit.HOURS);
```

Для обеспечения балансировки нагрузки между потоками используется алгоритм, который равномерно распределяет строки матрицы, учитывая возможный остаток:
```java
int rowsPerThread = m / threadCount;
int remainingRows = m % threadCount;

for (int threadIndex = 0; threadIndex < threadCount; threadIndex++) {
    int rowsForThisThread = rowsPerThread + (threadIndex < remainingRows ? 1 : 0);
    // Каждому потоку назначается свой диапазон строк
}
```
Это гарантирует, что разница в количестве строк, обрабатываемых разными потоками, не превышает 1, что минимизирует время ожидания завершения самого загруженного потока.

Также программа корректно обрабатывает различные граничные случаи:
- проверка совместимости размеров матриц;
- обработка прерывания потоков;
- проверка доступности памяти перед созданием больших матриц.

## Основные методы умножения

multiplyParallel - центральный метод лабораторной работы, реализующий параллельное умножение матриц с использованием потоков ExecutorService. Метод выполняет следующие действия:
1. Проверяет совместимость размеров матриц для умножения;
2. Создает результирующую матрицу нужного размера;
3. Определяет оптимальное количество потоков с учетом размера матрицы;
4. Распределяет строки матрицы между потоками с равномерной нагрузкой;
5. Использует оптимизированный порядок циклов для повышения производительности;
6. Обеспечивает корректное завершение всех потоков.

Вместо классического порядка i -> j -> k используется i -> k -> j, что позволяет кэшировать значение firstMatrix[i][k] и многократно использовать его при вычислении элементов строки результирующей матрицы:
```java
for (int i = startRow; i < endRow; i++) {
    for (int k = 0; k < n; k++) {
        double temp = firstMatrix[i][k]; // Кэшируем значение
        if (Math.abs(temp) > 1e-12) {    // Пропускаем нулевые значения
            for (int j = 0; j < p; j++) {
                result[i][j] += temp * secondMatrix[k][j];
            }
        }
    }
}
```

multiplySingleThreaded - реализует однопоточное умножение матриц для сравнения производительности. Использует тот же оптимизированный алгоритм, но без многопоточности. 

## Методы управления многопоточностью

calculateOptimalThreads - метод подбора оптимального количества потоков для заданного размера матрицы.
```java
public static int calculateOptimalThreads(int targetSize) {
    if (targetSize <= 200) {
        return 1;
    }
    if (targetSize >= 2000) {
        return NUM_THREADS;
    }
    return empiricalThreadSelection(targetSize);
}
```
Метод учитывает:
- для маленьких матриц (не больше 200 элементов) использует 1 поток, так как накладные расходы на создание потоков превышают выгоду от параллелизации;
- для очень больших матриц (не меньше 2000 элементов) использует количество доступных ядер процессора;
- для средних матриц проводит быстрый тест на уменьшенной копии данных для эмпирического определения оптимального количества потоков.

generateMatrix - создает матрицу заданного размера со случайными значениями в диапазоне от 10 до 100. Использование ненулевых значений гарантирует, что все вычисления будут выполняться, что важно для точного измерения производительности.

verifyMultiplication - выполняет верификацию результатов параллельного умножения, сравнивая их с результатами однопоточной реализации.

## Работа программы

При запуске программа автоматически выполняет серию тестов на матрицах разного размера:
- Определение характеристик системы (количество процессоров, доступная память);
- Последовательное тестирование на матрицах размером 500х500, 1000х1000 и 1500х1500;
- Дополнительный тест на очень большой матрице (2000х2000), если позволяет память;
- Анализ результатов.