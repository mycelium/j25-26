### 7. Java: Parallel matrix multiplication

- реализовать функцию `public static double[][] multiplyParallel(double[][] firstMatrix, double[][] secondMatrix);`
- Реализация должна использовать многопоточность
- Вывести время выполнения для матриц большой размерности
- Сравнить время с однопоточной реализацией из лабораторной 1
- Подобрать оптимальное количество потоков под вашу платформу, описать подход к подбору в README

### Поиск оптимального количества потоков
Поиск оптимального клоичесвта потоков для параллельного перемножения происходит в методе findOptimalThreadCount, который принимает две матрицы. Данный метод для каждого количества потоков от 1 до  threadCountMax*2, где threadCountMax - это количество логических процессоров, проводит по 10 испытаний. Каждое испытание включает в себя перемножение матриц с помощью исходного времени и вычисление среднего времени перемножения для данного количества потоков. Затем среди полученных средних времен выбирается минимальное, количество потоков которое соответствует данному времени и считается минимальным. 

Метод testLargeMatrix выполняет перемножение больших матриц с учетом поиска для каждой оптимального количеств потоков. Для матриц меньше 12 столбцов количество потоков будет соответствовать количеству столбцов. Оптимальное количество потоков изменяется в зависимости от матриц и их размеров, но в среднем оно равно 16 потокам для моего ноутбука с процессором Intel core  i5 c 8 ядрами и 12 логическими процессорами.


#### Сравнение временивыполнения алгоритмов
Для сравнения времени выполнения перемножения с помощью обычного алгоритма ( оптимищированного в 1 лаб.работе)и параллельного алгоритма была составлена таблица, представленная ниже. В этой же таблице в последнем столбце показано среднее время выполнения программы с оптимальным количеством потоков - 16.
|  Размер матриц | multiply     |  multiplyParallel(12) |  multiplyParallel(16)   |
|----------------|--------------|-----------------------|-------------------------|
| 500 x 500      | 40   ms      | 13 ms                 |  7 ms                   |  
| 1000 x 1000    | 454  ms      | 80 ms                 |  53 ms                  | 
| 1500 x 1500    | 3517 ms      | 292 ms                |  270 ms                 |  

При сравнении видно, что использование параллельного перемножения более эффективно, чем использование простого умножения. Но при этом параллельное перемножения с оптимальным коичеством потоков имеет наимнеьшее время выполнения.