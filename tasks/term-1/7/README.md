\### 7. Java: Parallel matrix multiplication



\- реализовать функцию `public static double\[]\[] multiplyParallel(double\[]\[] firstMatrix, double\[]\[] secondMatrix);`

\- Реализация должна использовать многопоточность

\- Вывести время выполнения для матриц большой размерности

\- Сравнить время с однопоточной реализацией из лабораторной 1

\- Подобрать оптимальное количество потоков под вашу платформу, описать подход к подбору в README


Программа тестировалась на 16 потоковом процессоре.



| Размер матрицы | Кол-во потоков  | Время выполнения |
|----------------|-----------------|------------------|
| **50x50**      | 1 (однопоточный)| 0,33 мс          |
| **50x50** | 4 | 0,33 мс |
| **50x50** | 8 | 1,03 мс |
| **50x50** | 16 | 0,97 мс |
| | | |
| **200x200** | 1 (однопоточный) | 4,07 мс |
| **200x200** | 4 | 4,38 мс |
| **200x200** | 8 | 3,39 мс |
| **200x200** | 16 | 4,74 мс |
| | | |
| **500x500** | 1 (однопоточный) | 199,39 мс |
| **500x500** | 4 | 68,74 мс |
| **500x500** | 8 | 42,41 мс |
| **500x500** | 16 | 35,31 мс |
| | | |
| **1000x1000** | 1 (однопоточный) | 1576,30 мс |
| **1000x1000** | 4 | 325,01 мс |
| **1000x1000** | 8 | 287,52 мс |
| **1000x1000** | 16 | 240,09 мс |
| | | |
| **2000x2000** | 1 (однопоточный) | 49702,02 мс |
| **2000x2000** | 4 | 2158,51 мс |
| **2000x2000** | 8 | 2113,07 мс |
| **2000x2000** | 16 | 2011,13 мс |



Оптимальное количество потоков для моей платформы - 16, столько же, сколько и всего доступно процессов. Таким образом каждый процесс действительно выполняется параллельно, при этом не возникает борьбы потоков за ресурсы, так как в коде умножение рализовано так, что каждый поток работает со своим блоком данных. Однако на небольших матрицах эффективнее меньшее количество потоков, так как создание потоков требует времени и это время может превышать сами вычисления.
