
### Подбор оптимального количества потоков

Для оценки эффективности параллельного умножения использовались квадратные матрицы размером 1000 на 1000.  
Каждый вариант алгоритма запускался по 5 раз, по результатам считалось среднее время.

Характеристики платформы:

ОС: Windows 11, 64‑bit.

Java: JDK 23.

Количество логических процессоров: 4 (определено методом Runtime.getRuntime().availableProcessors())

Результаты измерений:

- Простое однопоточное умножение: **4752.4 мс**
- Блочное умножение: **2359.6 мс**

Параллельное умножение (деление по строкам, различное количество потоков):

- 1 поток: **2923.2 мс**
- 2 потока: **1958.8 мс**
- 4 потока: **3722.4 мс**
- 8 потоков: **3699.8 мс**
- 3 потока: **1825.8 мс**

Подход к подбору количества потоков:

1. Определение количества доступных логических процессоров через  
   `Runtime.getRuntime().availableProcessors()` - было получено 4.
2. Запуск параллельное умножение с различным числом потоков: 1, 2, 4, 8  
   (то есть от 1 и далее, удваивая каждый раз, просто быстрая стратегия перебора, чтобы не перебирать каждое значение).
3. Измерение среднего время выполнения по 5 запусков для каждого варианта.
4. Сразу стало видно, что для 4 потоков и дальше среднее время увеличивается(по сравнению с двумя потоками), из этих вариантов 2 потока - самый лучший результат.
5. Для уточнения оптимального значения добавлено промежуточное значение (3 потока).
6. Найдено самое минимальное время - при 3 потоках.

По результатам эксперимента на моей платформе минимальное время показывает вариант с **3 потоками** (≈1826 мс).  
При увеличении числа потоков до 4 и 8 выполнение становится **медленнее**, так как растут накладные расходы на создание потоков и переключение контекста, а также возрастает конкуренция за ресурсы процессора и кэш.

Таким образом, оптимальным количеством потоков для моей платформы является **3 потока**.
