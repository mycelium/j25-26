### 7. Java: Parallel matrix multiplication

- Реализовать функцию `public static double[][] multiplyParallel(double[][] firstMatrix, double[][] secondMatrix)`.
- Реализация должна использовать многопоточность (ручное управление потоками).
- Вывести время выполнения для матриц большой размерности.
- Сравнить время с однопоточной реализацией из лабораторной 1.
- Подобрать оптимальное количество потоков под вашу платформу.

### Результаты тестирования параллельного умножения матриц

**Доступные логические процессоры:** 16

| Размер матрицы | Режим                  | Кол-во потоков | Среднее время (мс) | Ускорение (Speedup) |
|----------------|------------------------|----------------|--------------------|---------------------|
| 200            | Однопоточный           | 1              | 13.687             | -                   |
| 200            | Параллельный           | 2              | 6.776              | 2.02x               |
| 200            | Параллельный           | 8              | 4.742              | 2.89x               |
| 200            | Параллельный           | 16             | 4.083              | 3.35x               |
| 500            | Однопоточный           | 1              | 349.222            | -                   |
| 500            | Параллельный           | 2              | 101.148            | 3.45x               |
| 500            | Параллельный           | 8              | 35.510             | 9.83x               |
| 500            | Параллельный           | 16             | 22.337             | 15.63x              |
| 1000           | Однопоточный           | 1              | 3823.558           | -                   |
| 1000           | Параллельный           | 2              | 834.857            | 4.58x               |
| 1000           | Параллельный           | 8              | 219.755            | 17.40x              |
| 1000           | Параллельный           | 16             | 163.083            | 23.45x              |

---

### Выводы и анализ производительности

 **Выбор оптимального количества потоков:**
    * Для **малых задач** (< 500 элементов) увеличение числа потоков выше 8 не дает существенного прироста.
    * Для **больших задач** (>= 1000) использование всех доступных ядер (**16 потоков**) дает наилучший результат (163 мс против 220 мс на 8 потоках), снижая время выполнения еще на ~25%.
    * **Итог:** Оптимальным решением является использование количества потоков, равного количеству доступных логических ядер (`Runtime.getRuntime().availableProcessors()`), так как на тяжелых задачах это дает максимальный выигрыш благодаря эффективному использованию кэша.