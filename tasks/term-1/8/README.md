# 8. Java: Image Classification with DeepLearning4j (DL4J)

Данный проект представляет собой полную реализацию системы классификации изображений, способной определять цифры от 0 до 9 на основе знаменитого датасета MNIST. Он построен на библиотеке DeepLearning4J (DL4J) - фреймворк глубокого обучения для Java и JVM.

## Сверточная нейронная сеть (CNN)

Основная идея CNN заключается в использовании фильтров (ядер свертки), которые выявляют характерные признаки: линии, углы, текстуры.

Архитектура сети состоит из:
1. Входной слой: принимает изображения размером 28×28 пикселей с одним каналом (оттенки серого);
2. Сверточные слои: два последовательных слоя, которые извлекают иерархические признаки из изображений;
3. Слои подвыборки: уменьшают пространственные размеры представлений, сохраняя важную информацию;
4. Полносвязный слой: объединяет извлеченные признаки для принятия решений;
5. Выходной слой: производит окончательную классификацию на 10 категорий.

В коде архитектура реализована в методе createModelConfig() класса MNISTClassifier:
```java
public static MultiLayerConfiguration createModelConfig() {
    return new NeuralNetConfiguration.Builder()
        .seed(12345)
        .updater(new Adam(0.001))
        .list()
        .layer(new ConvolutionLayer.Builder(5, 5)
            .nIn(1)
            .stride(1, 1)
            .nOut(20)
            .activation(Activation.RELU)
            .build())
        // ... остальные слои
        .setInputType(InputType.convolutionalFlat(28, 28, 1))
        .build();
}
```

## Процесс обучения

В проекте обучение нейронной сети реализован в методе trainAndEvaluate(). Алгоритм обучения проходит через следующие этапы:
1. Инициализация весов: используется метод Xavier, который учитывает количество входных и выходных нейронов для оптимальной инициализации.
2. Прямое распространение: изображение проходит через все слои сети, на каждом шаге преобразуясь в более абстрактные представления.
3. Вычисление ошибки: сравнивается предсказание сети с реальной меткой (цифрой).
4. Обратное распространение: вычисляются градиенты - направления, в которых нужно изменить веса для уменьшения ошибки.
5. Обновление весов: оптимизатор Adam корректирует веса на основе вычисленных градиентов.

Используется стратегия ленивого обучения: при первом запуске система обучается с нуля, но затем сохраняет модель в файл. При последующих запусках она загружает уже обученную модель, экономя вычислительные ресурсы и время.

## Обработка изображений

В методе loadAndProcessImage() реализован полный конвейер обработки:
```java
public static INDArray loadAndProcessImage(String imagePath) throws IOException {
    BufferedImage originalImage = ImageIO.read(imageFile);
    
    // Преобразование в градации серого и изменение размера
    BufferedImage processedImage = new BufferedImage(
        IMAGE_SIZE, IMAGE_SIZE, BufferedImage.TYPE_BYTE_GRAY
    );
    // Нормализация и инвертирование
    for (int y = 0; y < IMAGE_SIZE; y++) {
        for (int x = 0; x < IMAGE_SIZE; x++) {
            int pixel = processedImage.getRGB(x, y) & 0xFF;
            double normalizedValue = pixel / 255.0;
            
            if (pixel > 128) {
                normalizedValue = 0.1; // Почти белый
            } else {
                normalizedValue = 0.9; // Почти черный
            }
        }
    }
}
```
В оригинальном датасете MNIST цифры представлены белым цветом на черном фоне, но пользовательские изображения обычно имеют черные цифры на белом фоне, поэтому инвертирование важно.

## Механизм предсказания

Когда обученная сеть получает новое изображение, происходит процесс, реализованный в методе predictFromImage():
```java
public static int predictFromImage(MultiLayerNetwork model, String imagePath) throws Exception {
    INDArray input = loadAndProcessImage(imagePath);    // Шаг 1: Подготовка данных
    INDArray output = model.output(input);              // Шаг 2: Прямой проход
    return output.argMax(1).getInt(0);                  // Шаг 3: Интерпретация
}
```
Шаг 1: Изображение преобразуется в числовой тензор размерности [1, 1, 28, 28], где:
- Первое измерение: номер примера в батче (1)
- Второе измерение: количество каналов (1 - grayscale)
- Третье и четвертое: высота и ширина (28×28)

Шаг 2: Тензор проходит через все обученные слои сети. Каждый слой применяет линейные преобразования (умножение на матрицу весов) и нелинейные активации.

Шаг 3: На выходе получается вектор из 10 чисел. Функция argMax() находит индекс максимального значения - это и есть предсказанная цифра.

## Генерация тестовых данных

Если реальные файлы не найдены, то автоматически создаются тестовые изображения. Метод createTestDigitImage() генерирует простые геометрические представления цифр:
```java
public static INDArray createTestDigitImage(int digit) {
    INDArray input = Nd4j.create(1, 1, IMAGE_SIZE, IMAGE_SIZE);
    
    switch (digit) {
        case 0: // Генерация круга/овала
            if ((x-14)*(x-14)/64.0 + (y-14)*(y-14)/100.0 <= 1) {
                value = 0.9; // Темный пиксель
            }
            break;
        case 1: // Вертикальная линия
            if (x >= 12 && x <= 16) value = 0.9;
            break;
        // ... аналогично для других цифр
    }
}
```
## Система оценки
После обучения система автоматически оценивает свою производительность с помощью класса Evaluation из DL4J. Метод evaluate() вычисляет несколько ключевых метрик:
- Общую долю правильных предсказаний;
- Точность для каждого класса;
- Полноту для каждого класса;
- Гармоническое среднее точности и полноты для каждого класса;
- Матрицу ошибок (визуальное представление всех правильных и неправильных предсказаний).